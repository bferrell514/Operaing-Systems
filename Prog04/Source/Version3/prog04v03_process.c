#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

/**
 * @file prog04v03_process.c
 * @author Baheem Ferrell
 * @date 22 Oct 2020
 */

/**
 * @brief A data container to store an integer value and a string.
 *
 * FileLine contains an integer value that represents the line index and
 * a char * value to store a line of text from input file.
 */
typedef struct FileLine
{
	int index;
	char * line;
} FileLine;

/**
 * @brief Compare function for qsort().
 * This function determines whether the line referenced by a comes before
 * the line referenced by b and returns the result as an integer value.
 * @param a Pointer to a FileLine data a
 * @param b Pointer to a FileLine data b
 * @return Returns -1 if a comes before b,
 * 1 if a comes after b,
 * 0 otherwise.
 */
int compareFunction(const void * a, const void * b)
{
	return ((*(FileLine *)a).index - (*(FileLine *)b).index);
}

/**
 * @brief Read n lists of files to create a list of files to be processed
 * This function reads i-th list of every n lists generated by n distributors
 * and create a list of files to be processed by this process.
 * @param n Number of processes.
 * @param pIndex Process index for this process.
 * @param fileNamesAddr Pointer to the list of file names (output).
 * @param fileCountAddr Pointer to the number of files.
 */
void readFileLists(int n, int pIndex, char *** fileNamesAddr, int * fileCountAddr)
{
	char ** fileNames = NULL;
	int fileCount = 0;
	// Read index files
	for (int i = 0; i < n; i++)
	{
		// Open file
		char fileName[10];
		sprintf(fileName, "%d.list", i);
		FILE * inFile = fopen(fileName, "r");
		// Read n lists
		for (int j = 0; j < n; j++)
		{
			// Read first line to get count
			size_t len = 0;
			ssize_t read = 0;
			char * line = NULL;
			read = getline(&line, &len, inFile);
			if (line[strlen(line) - 1] == (char)'\0')
				line[strlen(line) - 1] = (char)'\0';
			int count = atoi(line);
			free(line);
			line = NULL;
			// Increase file name list, if necessary
			if (j == pIndex && count > 0)
			{
				// Create, if empty
				if (fileCount == 0)
				{
					fileNames = (char **)malloc(sizeof(char *) * (fileCount + count));
				}
				// Expand and replace, if not big enough
				else
				{
					char ** newFileNames = (char **)malloc(sizeof(char *) * (fileCount + count));
					memcpy(newFileNames, fileNames, sizeof(char *) * fileCount);
					free(fileNames);
					fileNames = newFileNames;
				}
			}
			// Get file paths
			for (int k = 0; k < count; k++)
			{
				// Read a line
				len = 0;
				read = 0;
				read = getline(&line, &len, inFile);
				// Append to list, if this file is assigned to this process
				if (j == pIndex)
				{
					if (line[strlen(line) - 1] == (char)'\n')
						line[strlen(line) - 1] = (char)'\0';
					fileNames[fileCount++] = line;
				}
				// Otherwise, delete
				else
					free(line);
				line = NULL;
			}
		}
	}
	// Output
	*fileNamesAddr = fileNames;
	*fileCountAddr = fileCount;
}

/**
 * @brief Read files and returns a sorted string.
 * This function reads files specified in fileNames
 * and sorts them according to line numbers and returns the 
 * concatenated result as a char * value.
 * @param fileNames List of file paths.
 * @param fileCount Number of files in the list.
 * @return Ordered and concatenated string of file lines.
 */
char * processFiles(char ** fileNames, int fileCount)
{
	// Create Line array
	FileLine * lines = (FileLine *)malloc(sizeof(FileLine) * fileCount);
	memset(lines, 0, sizeof(FileLine) * fileCount);
	// Populate lines
	int length = 0;
	for (int i = 0; i < fileCount; i++)
	{
		// Open file
		FILE * file = fopen(fileNames[i], "r"); 
		if (file == NULL)
		{
			printf("Cannot open input file for processing %s.\n", fileNames[i]);
			return NULL;
		}
		// Read line index
		int lineIndex = 0;
		fscanf(file, "%d %d ", &lineIndex, &lineIndex);
		lines[i].index = lineIndex;
		// Read line
		size_t len = 0;
		ssize_t read = 0;
		char * line = NULL;
		read = getline(&line, &len, file);
		if (read < 0 || line == NULL || len < 1)
		{
			length += 1;
			lines[i].line = NULL;
			free(line);
		}
		else
		{
			if (line[strlen(line) - 1] == (char)'\n')
				line[strlen(line) - 1] = (char)'\0';
			lines[i].line = line;
			length += strlen(line) + 1;
		}
		fclose(file);
	}
	// Sort
	qsort(lines, fileCount, sizeof(FileLine), compareFunction);
	// Merge lines
	char * result = (char *)malloc(length + 1);
	length = 0;
	for (int i = 0; i < fileCount; i++)
	{
		if (lines[i].line != NULL)
		{
			strcpy(result + length, lines[i].line);
			length += strlen(lines[i].line);
		}
		result[length++] = (char)'\n';
		result[length] = (char)'\0';
		free(lines[i].line);
		lines[i].line = NULL;
	}
	free(lines);
	// Output
	return result;
}

/**
 * @brief Save processed result as a text file.
 * This function opens a file (i.result) and prints the text
 * referenced by result value.
 * @param pIndex Process index.
 * @param result Result text to print.
 */
void saveProcessedResult(int pIndex, char * result)
{
	// Open output file
	char fileName[10];
	sprintf(fileName, "%d.result", pIndex);
	FILE * outFile = fopen(fileName, "w");
	if (outFile == NULL)
	{
		printf("Cannot write result file %s.\n", fileName);
		return;
	}
	fprintf(outFile, "%s", result);
	// Close file
	fclose(outFile);
}

/**
 * @brief Entry point.
 * This function reads lines from a list of files and
 * saves the sorted results to a file.
 * @param argc Number of command line arguments.
 * @param argv An array of command line arguments.
 * @return Returns 0, if successful, non-zero otherwise.
 */
int main(int argc, char * argv[])
{
	/* Parse input arugments */
	int n = atoi(argv[1]);
	int pIndex = atoi(argv[2]);

	/* Read lines from a list of files */
	char ** fileNames = NULL;
	int fileCount = 0;
	readFileLists(n, pIndex, &fileNames, &fileCount);

	/* Process source files */
	char * result = processFiles(fileNames, fileCount);

	/* Output result */
	saveProcessedResult(pIndex, result);

	/* Clean up variables */
	for (int i = 0; i < fileCount; i++)
		free(fileNames[i]);
	free(fileNames);

	/* Exit */
	return 0;
}